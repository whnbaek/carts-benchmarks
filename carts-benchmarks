#!/usr/bin/env bash
################################################################################
# carts-benchmarks - Build script for carts benchmarks suite
#
# Usage: carts-benchmarks <benchmark> [size] [arts.cfg]
#
# Arguments:
#   benchmark  - Benchmark name (e.g., "polybench/2mm", "sw4lite/rhs4sg-base")
#   size       - Problem size: small, medium, large, or "default" (optional)
#   arts.cfg   - Path to ARTS configuration file (optional)
#
# Examples:
#   carts-benchmarks polybench/2mm small
#   carts-benchmarks sw4lite/rhs4sg-base medium /path/to/arts.cfg
#   carts-benchmarks ml-kernels/batchnorm large
#   carts-benchmarks simple-kernels/stream
################################################################################

set -euo pipefail

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Functions
usage() {
    cat <<EOF
Usage: carts-benchmarks <command> [options]

Build and manage carts benchmarkss.

Commands:
  <benchmark> [size] [arts.cfg]  Build a benchmark
  clean <target>                 Clean build artifacts
  list                           List all available benchmarks

Build Arguments:
  benchmark    Benchmark name (e.g., "polybench/2mm", "sw4lite/rhs4sg-base")
  size         Problem size: small, medium, large, or "default" (default: "default")
  arts.cfg     Path to ARTS configuration file (optional)

Clean Arguments:
  target       Benchmark, suite, or --all
               Examples: polybench/2mm, sw4lite, --all

Examples:
  carts-benchmarks polybench/2mm small
  carts-benchmarks sw4lite/rhs4sg-base medium /path/to/arts.cfg
  carts-benchmarks ml-kernels/batchnorm large
  carts-benchmarks simple-kernels/stream

  carts-benchmarks clean polybench/2mm        # Clean specific benchmark
  carts-benchmarks clean sw4lite              # Clean entire suite
  carts-benchmarks clean --all                # Clean all benchmarks

Available benchmarks:
  Polybench:          polybench/{2mm,3mm,atax,bicg,correlation,convolution-2d,
                      convolution-3d,fdtd-2d,gemm,jacobi2d,seidel-2d}
  ML Kernels:         ml-kernels/{activations,batchnorm,layernorm,pooling}
  SW4Lite:            sw4lite/{rhs4sg-base,rhs4sg-revnw,vel4sg-base}
  SPECFEM3D:          specfem3d/{stress,velocity}
  SeisSol:            seissol/volume-integral
  KaStORS:            kastors/{jacobi,sparselu,strassen}/*
  Task Parallelism:   task-parallelism-omp/{get-time,merge-serial,merge-tasks,quick-tasks}
  Simple Kernels:     simple-kernels/{stream,axpy}
  Miniapps:           miniapps/stencil2d
  NPB:                npb/ep
  PRK:                prk/stencil
  Llama2:             llama2-transformer/transformer

Size configurations (where applicable):
  small    - ~1,000 elements/iterations
  medium   - ~10,000 elements/iterations
  large    - ~100,000 elements/iterations
  default  - Build with default parameters

EOF
    exit 1
}

info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
    exit 1
}

# List function
list_benchmarks() {
    echo "Available carts benchmarkss"
    echo "============================"
    echo ""

    # Find all benchmarks with Makefiles and group by suite
    find "$SCRIPT_DIR" -mindepth 2 -maxdepth 4 -type f -name "Makefile" 2>/dev/null | while read -r makefile_path; do
        local dir=$(dirname "$makefile_path")
        local rel_path="${dir#$SCRIPT_DIR/}"
        local dirname=$(basename "$dir")

        # Skip common/non-benchmark directories
        case "$dirname" in
            common|include|src|utilities|.git|.svn|.hg) continue ;;
            .*) continue ;;  # Skip hidden directories
        esac

        # Skip if it's just the script directory
        if [ "$rel_path" = "." ] || [ "$rel_path" = "" ]; then
            continue
        fi

        # Skip disabled benchmarks
        if [ -f "$dir/.disabled" ]; then
            continue
        fi

        echo "$rel_path"
    done | sort | awk -F'/' '
    BEGIN { current_suite = "" }
    {
        suite = $1
        if (suite != current_suite) {
            if (current_suite != "") print ""
            print suite ":"
            current_suite = suite
        }
        print "  " $0
    }
    END { print "" }'

    echo "Usage:"
    echo "  carts benchmarks <benchmark> [size]"
    echo ""
    echo "Examples:"
    echo "  carts benchmarks polybench/2mm small"
    echo "  carts benchmarks sw4lite/rhs4sg-base medium"
    echo "  carts benchmarks ml-kernels/batchnorm large"
    echo ""
    echo "Commands:"
    echo "  carts benchmarks list          List all benchmarks"
    echo "  carts benchmarks clean <name>  Clean build artifacts"
}

# Clean function
clean_benchmark() {
    local target="$1"
    local cleaned_count=0

    # Handle --all flag
    if [ "$target" = "--all" ] || [ "$target" = "-a" ]; then
        info "Cleaning all benchmarks in repository..."

        # Find and clean all build and log directories
        find "$SCRIPT_DIR" -type d \( -name "build" -o -name "logs" \) -exec rm -rf {} + 2>/dev/null || true

        # Remove MLIR files
        find "$SCRIPT_DIR" -type f -name "*.mlir" ! -path "*/common/*" -delete 2>/dev/null || true

        # Remove LLVM IR files
        find "$SCRIPT_DIR" -type f -name "*.ll" -delete 2>/dev/null || true

        # Remove metadata files
        find "$SCRIPT_DIR" -type f -name ".carts-metadata.json" -delete 2>/dev/null || true
        find "$SCRIPT_DIR" -type f -name "*-metadata.json" -delete 2>/dev/null || true

        # Remove object files
        find "$SCRIPT_DIR" -type f -name "*.o" -delete 2>/dev/null || true

        # Remove build marker files
        find "$SCRIPT_DIR" -type f -name ".build-passed" -delete 2>/dev/null || true

        success "Cleaned all benchmarks"
        return 0
    fi

    # Normalize target path
    target="${target#./}"
    target="${target%/}"

    local target_path="${SCRIPT_DIR}/${target}"

    # Check if target exists
    if [ ! -e "$target_path" ]; then
        error "Target not found: $target_path"
    fi

    # Determine if target is a suite or benchmark
    if [ -d "$target_path" ]; then
        info "Cleaning: $target"

        # If it's a suite (has subdirectories with Makefiles), clean recursively
        if [ -f "$target_path/Makefile" ]; then
            # It's a suite or benchmark with Makefile
            if make -C "$target_path" clean &>/dev/null; then
                cleaned_count=$((cleaned_count + 1))
                info "Cleaned via Makefile: $target"
            fi
        fi

        # Clean build and logs directories
        if [ -d "$target_path/build" ]; then
            rm -rf "$target_path/build"
            cleaned_count=$((cleaned_count + 1))
        fi

        if [ -d "$target_path/logs" ]; then
            rm -rf "$target_path/logs"
            cleaned_count=$((cleaned_count + 1))
        fi

        # Clean MLIR and LLVM files
        find "$target_path" -maxdepth 1 -type f \( -name "*.mlir" -o -name "*.ll" \) -delete 2>/dev/null && cleaned_count=$((cleaned_count + 1)) || true

        # Clean metadata files
        find "$target_path" -maxdepth 1 -type f \( -name ".carts-metadata.json" -o -name "*-metadata.json" \) -delete 2>/dev/null && cleaned_count=$((cleaned_count + 1)) || true

        # Clean object files
        find "$target_path" -maxdepth 1 -type f -name "*.o" -delete 2>/dev/null || true

        # If it's a suite directory, clean all subdirectories
        if [ ! -f "$target_path/Makefile" ] || [ -d "$target_path/common" ]; then
            info "Detected suite directory, cleaning all benchmarks..."
            for subdir in "$target_path"/*; do
                if [ -d "$subdir" ] && [ "$(basename "$subdir")" != "common" ]; then
                    if [ -f "$subdir/Makefile" ]; then
                        make -C "$subdir" clean &>/dev/null && cleaned_count=$((cleaned_count + 1)) || true
                    fi
                    rm -rf "$subdir/build" "$subdir/logs" 2>/dev/null || true
                    find "$subdir" -maxdepth 1 -type f \( -name "*.mlir" -o -name "*.ll" -o -name "*.o" -o -name "*-metadata.json" \) -delete 2>/dev/null || true
                fi
            done
        fi

        if [ $cleaned_count -eq 0 ]; then
            warning "No build artifacts found to clean in: $target"
        else
            success "Cleaned $target"
        fi
    else
        error "Target is not a directory: $target"
    fi
}

# Parse arguments
if [ $# -lt 1 ]; then
    usage
fi

# Handle help flags
if [ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "help" ]; then
    usage
fi

# Handle list command
if [ "$1" = "list" ] || [ "$1" = "-l" ] || [ "$1" = "--list" ]; then
    list_benchmarks
    exit 0
fi

# Handle clean command
if [ "$1" = "clean" ]; then
    if [ $# -lt 2 ] || [ "$2" = "-h" ] || [ "$2" = "--help" ]; then
        cat <<EOF
Usage: carts-benchmarks clean <target>

Clean build artifacts for benchmarks.

Arguments:
  target       Benchmark, suite, or --all

Examples:
  carts-benchmarks clean polybench/2mm        # Clean specific benchmark
  carts-benchmarks clean sw4lite              # Clean entire suite
  carts-benchmarks clean --all                # Clean all benchmarks

Removes:
  - build/ directories
  - logs/ directories
  - *.mlir files
  - *.ll files
  - *.o files
  - *-metadata.json files
  - .build-passed marker files

EOF
        exit 0
    fi
    clean_benchmark "$2"
    exit 0
fi

BENCHMARK="$1"
SIZE="${2:-default}"
ARTS_CFG="${3:-}"

# Normalize benchmark path
BENCHMARK="${BENCHMARK#./}"
BENCHMARK="${BENCHMARK%/}"

# Construct full benchmark path
BENCHMARK_PATH="${SCRIPT_DIR}/${BENCHMARK}"

# Check if benchmark exists
if [ ! -d "$BENCHMARK_PATH" ]; then
    error "Benchmark directory not found: $BENCHMARK_PATH"
fi

# Check if benchmark is disabled
if [ -f "$BENCHMARK_PATH/.disabled" ]; then
    REASON=$(cat "$BENCHMARK_PATH/.disabled" 2>/dev/null || echo "No reason provided")
    error "Benchmark is disabled: $BENCHMARK
Reason: $REASON

To re-enable, remove the .disabled file from the benchmark directory."
fi

# Check if Makefile exists
if [ ! -f "$BENCHMARK_PATH/Makefile" ]; then
    error "No Makefile found in: $BENCHMARK_PATH"
fi

# Check if this is a parent/wrapper Makefile with subdirectories
HAS_SUBDIRS=false
if grep -q '^\$(MAKE) -C' "$BENCHMARK_PATH/Makefile" 2>/dev/null || \
   grep -q '^[[:space:]]*\$(MAKE) -C' "$BENCHMARK_PATH/Makefile" 2>/dev/null; then
    HAS_SUBDIRS=true
fi

# If it's a parent directory and size is specified (not default), provide helpful error
if [ "$HAS_SUBDIRS" = true ] && [ "$SIZE" != "default" ]; then
    # Extract subdirectory names from Makefile
    # Try multiple patterns to find subdirectory names
    SUBDIRS=""

    # Pattern 1: Look for EXAMPLES := or similar variable definitions
    if [ -z "$SUBDIRS" ]; then
        SUBDIRS=$(grep -E '^[A-Z_]+[[:space:]]*:?=[[:space:]]*' "$BENCHMARK_PATH/Makefile" | \
                  grep -v '^#' | head -1 | \
                  sed -E 's/^[A-Z_]+[[:space:]]*:?=[[:space:]]*//' | \
                  tr ' ' '\n' | grep -v '^$')
    fi

    # Pattern 2: Look for phony targets (excluding common ones)
    if [ -z "$SUBDIRS" ]; then
        SUBDIRS=$(grep -E '^\.PHONY:' "$BENCHMARK_PATH/Makefile" | \
                  sed -E 's/^\.PHONY:[[:space:]]*//' | \
                  tr ' ' '\n' | \
                  grep -v -E '^(all|clean|test|install)$')
    fi

    # Pattern 3: Look for actual subdirectories
    if [ -z "$SUBDIRS" ]; then
        SUBDIRS=$(find "$BENCHMARK_PATH" -mindepth 1 -maxdepth 1 -type d ! -name ".*" ! -name "build" ! -name "common" -exec basename {} \; | head -10)
    fi

    SUBDIRS=$(echo "$SUBDIRS" | head -10)

    error "Cannot specify size for suite directory: $BENCHMARK

This appears to be a suite directory containing multiple benchmarks.
Please specify a specific benchmark, for example:
$(echo "$SUBDIRS" | sed "s|^|  $BENCHMARK/|")

Or use 'default' to build all benchmarks with default settings:
  carts benchmarks $BENCHMARK"
fi

# Validate size parameter
if [ "$SIZE" != "default" ] && [ "$SIZE" != "small" ] && [ "$SIZE" != "medium" ] && [ "$SIZE" != "large" ]; then
    error "Invalid size: $SIZE (must be: small, medium, large, or default)"
fi

info "Building benchmark: $BENCHMARK"
info "Problem size: $SIZE"

# Set up ARTS configuration if provided
MAKE_ARGS=()
if [ -n "$ARTS_CFG" ]; then
    if [ ! -f "$ARTS_CFG" ]; then
        error "ARTS configuration file not found: $ARTS_CFG"
    fi
    ARTS_CFG_ABS="$(cd "$(dirname "$ARTS_CFG")" && pwd)/$(basename "$ARTS_CFG")"
    info "Using ARTS config: $ARTS_CFG_ABS"
    MAKE_ARGS+=("ARTS_CFG=$ARTS_CFG_ABS")
else
    # Detect which arts.cfg will be used (search order: benchmark dir, parent dirs, root)
    DETECTED_CFG=""
    SEARCH_DIR="$BENCHMARK_PATH"
    while [ "$SEARCH_DIR" != "$SCRIPT_DIR" ] && [ -n "$SEARCH_DIR" ]; do
        if [ -f "$SEARCH_DIR/arts.cfg" ]; then
            DETECTED_CFG="$SEARCH_DIR/arts.cfg"
            break
        fi
        SEARCH_DIR="$(dirname "$SEARCH_DIR")"
    done
    # Check root directory
    if [ -z "$DETECTED_CFG" ] && [ -f "$SCRIPT_DIR/arts.cfg" ]; then
        DETECTED_CFG="$SCRIPT_DIR/arts.cfg"
    fi

    if [ -n "$DETECTED_CFG" ]; then
        # Make path relative to script dir for cleaner output
        REL_CFG="${DETECTED_CFG#$SCRIPT_DIR/}"
        info "Detected ARTS config: $REL_CFG"
    else
        warning "No arts.cfg found - using CARTS runtime defaults"
    fi
fi

# Determine target based on size
if [ "$SIZE" = "default" ]; then
    TARGET="all"
else
    TARGET="$SIZE"
fi

# Build the benchmark
BUILD_START_TIME=$(date +%s)
if [ ${#MAKE_ARGS[@]} -gt 0 ]; then
    info "Compiling with: carts execute -O3"
    if make -C "$BENCHMARK_PATH" "$TARGET" "${MAKE_ARGS[@]}"; then
        BUILD_SUCCESS=true
    else
        BUILD_SUCCESS=false
    fi
else
    info "Compiling with: carts execute -O3"
    if make -C "$BENCHMARK_PATH" "$TARGET"; then
        BUILD_SUCCESS=true
    else
        BUILD_SUCCESS=false
    fi
fi
BUILD_END_TIME=$(date +%s)
BUILD_TIME=$((BUILD_END_TIME - BUILD_START_TIME))

if [ "$BUILD_SUCCESS" = true ]; then
    success "Compilation completed (${BUILD_TIME}s)"
else
    error "Compilation failed"
    error "Check logs in $BENCHMARK_PATH/logs/ for details"
    exit 1
fi

# Find the generated binary/MLIR files
BUILD_DIR="$BENCHMARK_PATH/build"
if [ ! -d "$BUILD_DIR" ]; then
    warning "Build directory not found: $BUILD_DIR"
    exit 0
fi

# Extract benchmark name from path
BENCH_NAME=$(basename "$BENCHMARK_PATH")
SUITE_NAME=$(basename "$(dirname "$BENCHMARK_PATH")")

# Look for MLIR files
echo
info "Generated artifacts in $BUILD_DIR:"
ARTIFACT_COUNT=0
if [ -f "$BUILD_DIR/${BENCH_NAME}_seq.mlir" ]; then
    echo "  ✓ Sequential MLIR: ${BENCH_NAME}_seq.mlir"
    ARTIFACT_COUNT=$((ARTIFACT_COUNT + 1))
fi
if [ -f "$BUILD_DIR/${BENCH_NAME}.mlir" ]; then
    echo "  ✓ Parallel MLIR: ${BENCH_NAME}.mlir"
    ARTIFACT_COUNT=$((ARTIFACT_COUNT + 1))
fi
if [ -f "$BUILD_DIR/${BENCH_NAME}.carts-metadata.json" ]; then
    echo "  ✓ Metadata: ${BENCH_NAME}.carts-metadata.json"
    ARTIFACT_COUNT=$((ARTIFACT_COUNT + 1))
fi

if [ $ARTIFACT_COUNT -eq 0 ]; then
    warning "No artifacts generated"
fi

echo
success "Benchmark ready: $SUITE_NAME/$BENCH_NAME"
if [ -f "$BUILD_DIR/${BENCH_NAME}.mlir" ]; then
    info "Primary artifact: $BUILD_DIR/${BENCH_NAME}.mlir"
fi
info "Build time: ${BUILD_TIME}s"

# Output the primary artifact path for scripting
if [ -f "$BUILD_DIR/${BENCH_NAME}.mlir" ]; then
    echo "$BUILD_DIR/${BENCH_NAME}.mlir"
fi
