[0;34m[INFO][0m Building benchmark: kastors/jacobi/jacobi-for
[0;34m[INFO][0m Problem size: small
[0;34m[INFO][0m Running: make -C /Users/randreshg/Documents/carts/external/carts-benchmarks/kastors/jacobi/jacobi-for small
[jacobi-for] Building with SMALL size (1024)
/Library/Developer/CommandLineTools/usr/bin/make all CFLAGS="-I../include -DSIZE=1024 "
[jacobi-for] Running carts --concurrency
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:o-i64:64-i128:128-n32:64-S128", llvm.target_triple = "arm64-apple-macosx16.0.0", "polygeist.target-cpu" = "apple-m1", "polygeist.target-features" = "+aes,+crc,+dotprod,+fp-armv8,+fp16fml,+fullfp16,+lse,+neon,+ras,+rcpc,+rdm,+sha2,+sha3,+v8.1a,+v8.2a,+v8.3a,+v8.4a,+v8.5a,+v8a,+zcm,+zcz"} {
  func.func @main() -> i32 attributes {llvm.linkage = #llvm.linkage<external>} {
    %c13 = arith.constant 13 : index
    %c8 = arith.constant 8 : index
    %c99_i32 = arith.constant 99 : i32
    %true = arith.constant true
    %c-1 = arith.constant -1 : index
    %cst = arith.constant 2.500000e-01 : f64
    %c100 = arith.constant 100 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %c11 = arith.constant 11 : index
    %c100_i64 = arith.constant 100 : i64
    %cst_0 = arith.constant 0.000000e+00 : f64
    %c0_i32 = arith.constant 0 : i32
    %0 = polygeist.typeSize memref<?xf64> : index
    %1 = arith.index_cast %0 : index to i64
    %2 = arith.muli %1, %c100_i64 : i64
    %3 = arith.index_cast %2 : i64 to index
    %4 = arith.divui %3, %0 : index
    %guid, %ptr = arts.db_alloc[<inout>, <heap>, <write>] route(%c0_i32 : i32) sizes[%c1] elementType(f64) elementSizes[%4, %c100] {arts.id = 14 : i64, arts.memref = #arts.memref_metadata<rank = 2 : i64, allocationId = "jacobi-for.c:66:21", totalAccesses = 6 : i64, readCount = 4 : i64, writeCount = 2 : i64, readWriteRatio = 0.66666666666666663 : f64, allAccessesAffine = true, hasNonAffineAccesses = false, firstUseId = 14 : i64, hasUniformAccess = false, dominantAccessPattern = 0 : i64, accessedInParallelLoop = true, hasLoopCarriedDeps = true, reuseDistance = 0 : i64, hasGoodSpatialLocality = true, dimAccessPatterns = [3, 3], estimatedAccessBytes = 48 : i64>} : (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
    %guid_1, %ptr_2 = arts.db_alloc[<inout>, <heap>, <write>] route(%c0_i32 : i32) sizes[%c1] elementType(f64) elementSizes[%4, %c100] {arts.id = 14 : i64, arts.memref = #arts.memref_metadata<rank = 2 : i64, allocationId = "jacobi-for.c:66:21", totalAccesses = 6 : i64, readCount = 4 : i64, writeCount = 2 : i64, readWriteRatio = 0.66666666666666663 : f64, allAccessesAffine = true, hasNonAffineAccesses = false, firstUseId = 14 : i64, hasUniformAccess = false, dominantAccessPattern = 0 : i64, accessedInParallelLoop = true, hasLoopCarriedDeps = true, reuseDistance = 0 : i64, hasGoodSpatialLocality = true, dimAccessPatterns = [3, 3], estimatedAccessBytes = 48 : i64>} : (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
    scf.for %arg0 = %c0 to %c100 step %c1 {
      scf.for %arg1 = %c0 to %c100 step %c1 {
        %5 = arts.db_ref %ptr[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
        memref.store %cst_0, %5[%arg0, %arg1] : memref<?x?xf64>
        %6 = arts.db_ref %ptr_2[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
        memref.store %cst_0, %6[%arg0, %arg1] : memref<?x?xf64>
      } {arts.id = 2 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 0 : i64, writeCount = 3 : i64, tripCount = 100 : i64, nestingLevel = 1 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 5 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 0 : i64, writeOnlyMemrefCount = 3 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
    } {arts.id = 3 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 0 : i64, writeCount = 3 : i64, tripCount = 100 : i64, nestingLevel = 0 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 5 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 0 : i64, writeOnlyMemrefCount = 3 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
    scf.for %arg0 = %c1 to %c11 step %c1 {
      %guid_3, %ptr_4 = arts.db_acquire[<in>] (%guid_1 : memref<?xi64>, %ptr_2 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
      %guid_5, %ptr_6 = arts.db_acquire[<out>] (%guid : memref<?xi64>, %ptr : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
      arts.edt <parallel> <intranode> route(%c0_i32) (%ptr_4, %ptr_6) : memref<?xmemref<memref<?x?xf64>>>, memref<?xmemref<memref<?x?xf64>>> attributes {workers = #arts.workers<8>} {
      ^bb0(%arg1: memref<?xmemref<memref<?x?xf64>>>, %arg2: memref<?xmemref<memref<?x?xf64>>>):
        %5 = arts.epoch {
          %6 = arts.get_parallel_worker_id
          %7 = arith.cmpi eq, %6, %c0 : index
          scf.if %7 {
            scf.for %arg3 = %c0 to %c8 step %c1 {
              %8 = arith.muli %arg3, %c13 : index
              %9 = arith.cmpi uge, %8, %c100 : index
              %10 = arith.subi %c100, %8 : index
              %11 = arith.select %9, %c0, %10 : index
              %12 = arith.minui %11, %c13 : index
              %13 = arith.cmpi ugt, %12, %c0 : index
              scf.if %13 {
                %guid_11, %ptr_12 = arts.db_acquire[<in>] ( %arg1 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] offset_hints[%8] size_hints[%12] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
                %guid_13, %ptr_14 = arts.db_acquire[<out>] ( %arg2 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] offset_hints[%8] size_hints[%12] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
                arts.edt <task> <intranode> route(%c0_i32) (%ptr_12, %ptr_14) : memref<?xmemref<memref<?x?xf64>>>, memref<?xmemref<memref<?x?xf64>>> {
                ^bb0(%arg4: memref<?xmemref<memref<?x?xf64>>>, %arg5: memref<?xmemref<memref<?x?xf64>>>):
                  scf.for %arg6 = %c0 to %12 step %c1 {
                    %14 = arith.addi %8, %arg6 : index
                    scf.for %arg7 = %c0 to %c100 step %c1 {
                      %15 = arts.db_ref %arg4[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                      %16 = memref.load %15[%14, %arg7] : memref<?x?xf64>
                      %17 = arts.db_ref %arg5[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                      memref.store %16, %17[%14, %arg7] : memref<?x?xf64>
                    } {arts.id = 4 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 1 : i64, writeCount = 1 : i64, tripCount = 100 : i64, nestingLevel = 2 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 16 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 2 : i64, readOnlyMemrefCount = 1 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
                  } {arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 1 : i64, writeCount = 1 : i64, tripCount = 100 : i64, nestingLevel = 1 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 16 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 2 : i64, readOnlyMemrefCount = 1 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
                  arts.db_release(%arg4) : memref<?xmemref<memref<?x?xf64>>>
                  arts.db_release(%arg5) : memref<?xmemref<memref<?x?xf64>>>
                }
              }
            }
          }
        } : i64
        arts.db_release(%arg1) : memref<?xmemref<memref<?x?xf64>>>
        arts.db_release(%arg2) : memref<?xmemref<memref<?x?xf64>>>
      }
      %guid_7, %ptr_8 = arts.db_acquire[<out>] (%guid_1 : memref<?xi64>, %ptr_2 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
      %guid_9, %ptr_10 = arts.db_acquire[<in>] (%guid : memref<?xi64>, %ptr : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
      arts.edt <parallel> <intranode> route(%c0_i32) (%ptr_8, %ptr_10) : memref<?xmemref<memref<?x?xf64>>>, memref<?xmemref<memref<?x?xf64>>> attributes {workers = #arts.workers<8>} {
      ^bb0(%arg1: memref<?xmemref<memref<?x?xf64>>>, %arg2: memref<?xmemref<memref<?x?xf64>>>):
        %5 = arts.epoch {
          %6 = arts.get_parallel_worker_id
          %7 = arith.cmpi eq, %6, %c0 : index
          scf.if %7 {
            scf.for %arg3 = %c0 to %c8 step %c1 {
              %8 = arith.muli %arg3, %c13 : index
              %9 = arith.cmpi uge, %8, %c100 : index
              %10 = arith.subi %c100, %8 : index
              %11 = arith.select %9, %c0, %10 : index
              %12 = arith.minui %11, %c13 : index
              %13 = arith.cmpi ugt, %12, %c0 : index
              scf.if %13 {
                %guid_11, %ptr_12 = arts.db_acquire[<out>] ( %arg1 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] offset_hints[%8] size_hints[%12] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
                %guid_13, %ptr_14 = arts.db_acquire[<in>] ( %arg2 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] offset_hints[%8] size_hints[%12] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
                arts.edt <task> <intranode> route(%c0_i32) (%ptr_12, %ptr_14) : memref<?xmemref<memref<?x?xf64>>>, memref<?xmemref<memref<?x?xf64>>> {
                ^bb0(%arg4: memref<?xmemref<memref<?x?xf64>>>, %arg5: memref<?xmemref<memref<?x?xf64>>>):
                  scf.for %arg6 = %c0 to %12 step %c1 {
                    %14 = arith.addi %8, %arg6 : index
                    %15 = arith.index_cast %14 : index to i32
                    %16 = arith.cmpi eq, %15, %c99_i32 : i32
                    scf.for %arg7 = %c0 to %c100 step %c1 {
                      %17 = arith.index_cast %arg7 : index to i32
                      %18 = arith.cmpi eq, %14, %c0 : index
                      %19 = scf.if %18 -> (i1) {
                        scf.yield %true : i1
                      } else {
                        %24 = arith.cmpi eq, %17, %c0_i32 : i32
                        scf.yield %24 : i1
                      }
                      %20 = arith.xori %19, %true : i1
                      %21 = arith.andi %20, %16 : i1
                      %22 = arith.ori %19, %21 : i1
                      %23 = scf.if %22 -> (i1) {
                        scf.yield %true : i1
                      } else {
                        %24 = arith.cmpi eq, %17, %c99_i32 : i32
                        scf.yield %24 : i1
                      }
                      scf.if %23 {
                        %24 = arts.db_ref %arg4[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                        memref.store %cst_0, %24[%14, %arg7] : memref<?x?xf64>
                      } else {
                        %24 = arith.addi %14, %c-1 : index
                        %25 = arts.db_ref %arg5[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                        %26 = memref.load %25[%24, %arg7] : memref<?x?xf64>
                        %27 = arith.addi %arg7, %c1 : index
                        %28 = memref.load %25[%14, %27] : memref<?x?xf64>
                        %29 = arith.addf %26, %28 : f64
                        %30 = arith.addi %arg7, %c-1 : index
                        %31 = memref.load %25[%14, %30] : memref<?x?xf64>
                        %32 = arith.addf %29, %31 : f64
                        %33 = arith.addi %14, %c1 : index
                        %34 = memref.load %25[%33, %arg7] : memref<?x?xf64>
                        %35 = arith.addf %32, %34 : f64
                        %36 = arith.addf %35, %cst_0 : f64
                        %37 = arith.mulf %36, %cst : f64
                        %38 = arts.db_ref %arg4[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                        memref.store %37, %38[%14, %arg7] : memref<?x?xf64>
                      }
                    } {arts.id = 6 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 6 : i64, writeCount = 2 : i64, tripCount = 100 : i64, nestingLevel = 2 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 4 : i64, suggestedChunkSize = 0 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 2 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
                  } {arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 6 : i64, writeCount = 2 : i64, tripCount = 100 : i64, nestingLevel = 1 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 4 : i64, suggestedChunkSize = 0 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 2 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
                  arts.db_release(%arg4) : memref<?xmemref<memref<?x?xf64>>>
                  arts.db_release(%arg5) : memref<?xmemref<memref<?x?xf64>>>
                }
              }
            }
          }
        } : i64
        arts.db_release(%arg1) : memref<?xmemref<memref<?x?xf64>>>
        arts.db_release(%arg2) : memref<?xmemref<memref<?x?xf64>>>
      }
    } {arts.id = 8 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = false, hasReductions = false, readCount = 7 : i64, writeCount = 3 : i64, tripCount = 10 : i64, nestingLevel = 0 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 4 : i64, suggestedChunkSize = 0 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = true, dependenceDistance = 1 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 1 : i64, writeOnlyMemrefCount = 0 : i64, readWriteMemrefCount = 2 : i64, memrefsWithLoopCarriedDeps = 2 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 3 : i64, locationKey = "-">}
    arts.db_free(%guid) : memref<?xi64>
    arts.db_free(%ptr) : memref<?xmemref<memref<?x?xf64>>>
    arts.db_free(%guid_1) : memref<?xi64>
    arts.db_free(%ptr_2) : memref<?xmemref<memref<?x?xf64>>>
    return %c0_i32 : i32
  }
}
[jacobi-for] Running carts --concurrency-opt
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:o-i64:64-i128:128-n32:64-S128", llvm.target_triple = "arm64-apple-macosx16.0.0", "polygeist.target-cpu" = "apple-m1", "polygeist.target-features" = "+aes,+crc,+dotprod,+fp-armv8,+fp16fml,+fullfp16,+lse,+neon,+ras,+rcpc,+rdm,+sha2,+sha3,+v8.1a,+v8.2a,+v8.3a,+v8.4a,+v8.5a,+v8a,+zcm,+zcz"} {
  func.func @main() -> i32 attributes {llvm.linkage = #llvm.linkage<external>} {
    %c13 = arith.constant 13 : index
    %c8 = arith.constant 8 : index
    %c99_i32 = arith.constant 99 : i32
    %true = arith.constant true
    %c-1 = arith.constant -1 : index
    %cst = arith.constant 2.500000e-01 : f64
    %c100 = arith.constant 100 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %c11 = arith.constant 11 : index
    %c100_i64 = arith.constant 100 : i64
    %cst_0 = arith.constant 0.000000e+00 : f64
    %c0_i32 = arith.constant 0 : i32
    %0 = polygeist.typeSize memref<?xf64> : index
    %1 = arith.index_cast %0 : index to i64
    %2 = arith.muli %1, %c100_i64 : i64
    %3 = arith.index_cast %2 : i64 to index
    %4 = arith.divui %3, %0 : index
    %guid, %ptr = arts.db_alloc[<inout>, <heap>, <write>] route(%c0_i32 : i32) sizes[%c1] elementType(f64) elementSizes[%4, %c100] {arts.id = 14 : i64, arts.memref = #arts.memref_metadata<rank = 2 : i64, allocationId = "jacobi-for.c:66:21", totalAccesses = 6 : i64, readCount = 4 : i64, writeCount = 2 : i64, readWriteRatio = 0.66666666666666663 : f64, allAccessesAffine = true, hasNonAffineAccesses = false, firstUseId = 14 : i64, hasUniformAccess = false, dominantAccessPattern = 0 : i64, accessedInParallelLoop = true, hasLoopCarriedDeps = true, reuseDistance = 0 : i64, hasGoodSpatialLocality = true, dimAccessPatterns = [3, 3], estimatedAccessBytes = 48 : i64>, arts.twin_diff = false} : (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
    %guid_1, %ptr_2 = arts.db_alloc[<inout>, <heap>, <write>] route(%c0_i32 : i32) sizes[%c1] elementType(f64) elementSizes[%4, %c100] {arts.id = 14 : i64, arts.memref = #arts.memref_metadata<rank = 2 : i64, allocationId = "jacobi-for.c:66:21", totalAccesses = 6 : i64, readCount = 4 : i64, writeCount = 2 : i64, readWriteRatio = 0.66666666666666663 : f64, allAccessesAffine = true, hasNonAffineAccesses = false, firstUseId = 14 : i64, hasUniformAccess = false, dominantAccessPattern = 0 : i64, accessedInParallelLoop = true, hasLoopCarriedDeps = true, reuseDistance = 0 : i64, hasGoodSpatialLocality = true, dimAccessPatterns = [3, 3], estimatedAccessBytes = 48 : i64>, arts.twin_diff = false} : (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
    scf.for %arg0 = %c0 to %c100 step %c1 {
      scf.for %arg1 = %c0 to %c100 step %c1 {
        %5 = arts.db_ref %ptr[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
        memref.store %cst_0, %5[%arg0, %arg1] : memref<?x?xf64>
        %6 = arts.db_ref %ptr_2[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
        memref.store %cst_0, %6[%arg0, %arg1] : memref<?x?xf64>
      } {arts.id = 2 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 0 : i64, writeCount = 3 : i64, tripCount = 100 : i64, nestingLevel = 1 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 5 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 0 : i64, writeOnlyMemrefCount = 3 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
    } {arts.id = 3 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 0 : i64, writeCount = 3 : i64, tripCount = 100 : i64, nestingLevel = 0 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 5 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 0 : i64, writeOnlyMemrefCount = 3 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
    scf.for %arg0 = %c1 to %c11 step %c1 {
      %guid_3, %ptr_4 = arts.db_acquire[<in>] (%guid_1 : memref<?xi64>, %ptr_2 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
      %guid_5, %ptr_6 = arts.db_acquire[<in>] (%guid : memref<?xi64>, %ptr : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
      arts.edt <parallel> <intranode> route(%c0_i32) (%ptr_4, %ptr_6) : memref<?xmemref<memref<?x?xf64>>>, memref<?xmemref<memref<?x?xf64>>> attributes {workers = #arts.workers<8>} {
      ^bb0(%arg1: memref<?xmemref<memref<?x?xf64>>>, %arg2: memref<?xmemref<memref<?x?xf64>>>):
        %5 = arts.epoch {
          %6 = arts.get_parallel_worker_id
          %7 = arith.cmpi eq, %6, %c0 : index
          scf.if %7 {
            scf.for %arg3 = %c0 to %c8 step %c1 {
              %8 = arith.muli %arg3, %c13 : index
              %9 = arith.cmpi uge, %8, %c100 : index
              %10 = arith.subi %c100, %8 : index
              %11 = arith.select %9, %c0, %10 : index
              %12 = arith.minui %11, %c13 : index
              %13 = arith.cmpi ugt, %12, %c0 : index
              scf.if %13 {
                %guid_11, %ptr_12 = arts.db_acquire[<in>] ( %arg1 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] offset_hints[%8] size_hints[%12] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
                %guid_13, %ptr_14 = arts.db_acquire[<out>] ( %arg2 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] offset_hints[%8] size_hints[%12] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
                arts.edt <task> <intranode> route(%c0_i32) (%ptr_12, %ptr_14) : memref<?xmemref<memref<?x?xf64>>>, memref<?xmemref<memref<?x?xf64>>> {
                ^bb0(%arg4: memref<?xmemref<memref<?x?xf64>>>, %arg5: memref<?xmemref<memref<?x?xf64>>>):
                  scf.for %arg6 = %c0 to %12 step %c1 {
                    %14 = arith.addi %8, %arg6 : index
                    scf.for %arg7 = %c0 to %c100 step %c1 {
                      %15 = arts.db_ref %arg4[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                      %16 = memref.load %15[%14, %arg7] : memref<?x?xf64>
                      %17 = arts.db_ref %arg5[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                      memref.store %16, %17[%14, %arg7] : memref<?x?xf64>
                    } {arts.id = 4 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 1 : i64, writeCount = 1 : i64, tripCount = 100 : i64, nestingLevel = 2 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 16 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 2 : i64, readOnlyMemrefCount = 1 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
                  } {arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 1 : i64, writeCount = 1 : i64, tripCount = 100 : i64, nestingLevel = 1 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 16 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 2 : i64, readOnlyMemrefCount = 1 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
                  arts.db_release(%arg4) : memref<?xmemref<memref<?x?xf64>>>
                  arts.db_release(%arg5) : memref<?xmemref<memref<?x?xf64>>>
                }
              }
            } {arts.id = 5 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 1 : i64, writeCount = 1 : i64, tripCount = 100 : i64, nestingLevel = 1 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 0 : i64, suggestedChunkSize = 32 : i64, memoryFootprintPerIter = 16 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 2 : i64, readOnlyMemrefCount = 1 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
          }
        } : i64
        arts.db_release(%arg1) : memref<?xmemref<memref<?x?xf64>>>
        arts.db_release(%arg2) : memref<?xmemref<memref<?x?xf64>>>
      }
      %guid_7, %ptr_8 = arts.db_acquire[<in>] (%guid_1 : memref<?xi64>, %ptr_2 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
      %guid_9, %ptr_10 = arts.db_acquire[<in>] (%guid : memref<?xi64>, %ptr : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
      arts.edt <parallel> <intranode> route(%c0_i32) (%ptr_8, %ptr_10) : memref<?xmemref<memref<?x?xf64>>>, memref<?xmemref<memref<?x?xf64>>> attributes {workers = #arts.workers<8>} {
      ^bb0(%arg1: memref<?xmemref<memref<?x?xf64>>>, %arg2: memref<?xmemref<memref<?x?xf64>>>):
        %5 = arts.epoch {
          %6 = arts.get_parallel_worker_id
          %7 = arith.cmpi eq, %6, %c0 : index
          scf.if %7 {
            scf.for %arg3 = %c0 to %c8 step %c1 {
              %8 = arith.muli %arg3, %c13 : index
              %9 = arith.cmpi uge, %8, %c100 : index
              %10 = arith.subi %c100, %8 : index
              %11 = arith.select %9, %c0, %10 : index
              %12 = arith.minui %11, %c13 : index
              %13 = arith.cmpi ugt, %12, %c0 : index
              scf.if %13 {
                %guid_11, %ptr_12 = arts.db_acquire[<out>] ( %arg1 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] offset_hints[%8] size_hints[%12] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
                %guid_13, %ptr_14 = arts.db_acquire[<in>] ( %arg2 : memref<?xmemref<memref<?x?xf64>>>) offsets[%c0] sizes[%c1] offset_hints[%8] size_hints[%12] -> (memref<?xi64>, memref<?xmemref<memref<?x?xf64>>>)
                arts.edt <task> <intranode> route(%c0_i32) (%ptr_12, %ptr_14) : memref<?xmemref<memref<?x?xf64>>>, memref<?xmemref<memref<?x?xf64>>> {
                ^bb0(%arg4: memref<?xmemref<memref<?x?xf64>>>, %arg5: memref<?xmemref<memref<?x?xf64>>>):
                  scf.for %arg6 = %c0 to %12 step %c1 {
                    %14 = arith.addi %8, %arg6 : index
                    %15 = arith.index_cast %14 : index to i32
                    %16 = arith.cmpi eq, %15, %c99_i32 : i32
                    scf.for %arg7 = %c0 to %c100 step %c1 {
                      %17 = arith.index_cast %arg7 : index to i32
                      %18 = arith.cmpi eq, %14, %c0 : index
                      %19 = scf.if %18 -> (i1) {
                        scf.yield %true : i1
                      } else {
                        %24 = arith.cmpi eq, %17, %c0_i32 : i32
                        scf.yield %24 : i1
                      }
                      %20 = arith.xori %19, %true : i1
                      %21 = arith.andi %20, %16 : i1
                      %22 = arith.ori %19, %21 : i1
                      %23 = scf.if %22 -> (i1) {
                        scf.yield %true : i1
                      } else {
                        %24 = arith.cmpi eq, %17, %c99_i32 : i32
                        scf.yield %24 : i1
                      }
                      scf.if %23 {
                        %24 = arts.db_ref %arg4[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                        memref.store %cst_0, %24[%14, %arg7] : memref<?x?xf64>
                      } else {
                        %24 = arith.addi %14, %c-1 : index
                        %25 = arts.db_ref %arg5[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                        %26 = memref.load %25[%24, %arg7] : memref<?x?xf64>
                        %27 = arith.addi %arg7, %c1 : index
                        %28 = memref.load %25[%14, %27] : memref<?x?xf64>
                        %29 = arith.addf %26, %28 : f64
                        %30 = arith.addi %arg7, %c-1 : index
                        %31 = memref.load %25[%14, %30] : memref<?x?xf64>
                        %32 = arith.addf %29, %31 : f64
                        %33 = arith.addi %14, %c1 : index
                        %34 = memref.load %25[%33, %arg7] : memref<?x?xf64>
                        %35 = arith.addf %32, %34 : f64
                        %36 = arith.addf %35, %cst_0 : f64
                        %37 = arith.mulf %36, %cst : f64
                        %38 = arts.db_ref %arg4[%c0] : memref<?xmemref<memref<?x?xf64>>> -> memref<?x?xf64>
                        memref.store %37, %38[%14, %arg7] : memref<?x?xf64>
                      }
                    } {arts.id = 6 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 6 : i64, writeCount = 2 : i64, tripCount = 100 : i64, nestingLevel = 2 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 4 : i64, suggestedChunkSize = 0 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 2 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
                  } {arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 6 : i64, writeCount = 2 : i64, tripCount = 100 : i64, nestingLevel = 1 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 4 : i64, suggestedChunkSize = 0 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 2 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
                  arts.db_release(%arg4) : memref<?xmemref<memref<?x?xf64>>>
                  arts.db_release(%arg5) : memref<?xmemref<memref<?x?xf64>>>
                }
              }
            } {arts.id = 7 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = true, hasReductions = false, readCount = 6 : i64, writeCount = 2 : i64, tripCount = 100 : i64, nestingLevel = 1 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 4 : i64, suggestedChunkSize = 0 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = false, dependenceDistance = 0 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 2 : i64, writeOnlyMemrefCount = 1 : i64, readWriteMemrefCount = 0 : i64, memrefsWithLoopCarriedDeps = 0 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 2 : i64, locationKey = "-">}
          }
        } : i64
        arts.db_release(%arg1) : memref<?xmemref<memref<?x?xf64>>>
        arts.db_release(%arg2) : memref<?xmemref<memref<?x?xf64>>>
      }
    } {arts.id = 8 : i64, arts.loop = #arts.loop_metadata<potentiallyParallel = false, hasReductions = false, readCount = 7 : i64, writeCount = 3 : i64, tripCount = 10 : i64, nestingLevel = 0 : i64, hasUniformStride = true, hasGatherScatter = false, dataMovementPattern = 4 : i64, suggestedPartitioning = 4 : i64, suggestedChunkSize = 0 : i64, memoryFootprintPerIter = 24 : i64, hasInterIterationDeps = true, dependenceDistance = 1 : i64, memrefCount = 3 : i64, readOnlyMemrefCount = 1 : i64, writeOnlyMemrefCount = 0 : i64, readWriteMemrefCount = 2 : i64, memrefsWithLoopCarriedDeps = 2 : i64, poorTemporalLocalityMemrefs = 0 : i64, parallelClassification = 3 : i64, locationKey = "-">}
    arts.db_free(%guid_1) : memref<?xi64>
    arts.db_free(%ptr_2) : memref<?xmemref<memref<?x?xf64>>>
    arts.db_free(%guid) : memref<?xi64>
    arts.db_free(%ptr) : memref<?xmemref<memref<?x?xf64>>>
    return %c0_i32 : i32
  }
}
[0;32m[SUCCESS][0m Build completed successfully

[0;34m[INFO][0m Generated artifacts in /Users/randreshg/Documents/carts/external/carts-benchmarks/kastors/jacobi/jacobi-for/build:
  - Parallel MLIR: /Users/randreshg/Documents/carts/external/carts-benchmarks/kastors/jacobi/jacobi-for/build/jacobi-for.mlir
  - Sequential MLIR: /Users/randreshg/Documents/carts/external/carts-benchmarks/kastors/jacobi/jacobi-for/build/jacobi-for_seq.mlir
  - Metadata: /Users/randreshg/Documents/carts/external/carts-benchmarks/kastors/jacobi/jacobi-for/build/jacobi-for.carts-metadata.json

[0;32m[SUCCESS][0m Benchmark ready: jacobi/jacobi-for
[0;32m[SUCCESS][0m Primary artifact: /Users/randreshg/Documents/carts/external/carts-benchmarks/kastors/jacobi/jacobi-for/build/jacobi-for.mlir
/Users/randreshg/Documents/carts/external/carts-benchmarks/kastors/jacobi/jacobi-for/build/jacobi-for.mlir
